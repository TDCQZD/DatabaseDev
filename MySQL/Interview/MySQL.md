# Mysql
## Mysql各种索引区别
- 普通索引：最基本的索引，没有任何限制
- 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
- 主键索引（聚簇索引）：它是一种特殊的唯一索引，不允许有空值。 
- 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。
- 组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。
## 事务
事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
### ACID
ACID，是指在可靠数据库管理系统（DBMS）中，事务(Transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
* 原子性

原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。

如，A向B转钱，在事务中的扣款和加款两条语句，要么都执行，要么都不执行。
* 一致性

一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。

如，A和B存款总额为1000，A向B转钱，无论失败，最终A和B的存款总额依然为1000.
* 隔离性

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

数据库多个事务之间操作可能出现的问题以及事务隔离级别是这篇文章介绍的重点。
* 持久性

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。
### 事务的并发问题
* 赃读（Dirty Read）

一个事务读取到了另外一个事务没有提交的数据

事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
* 不可重复读（Nonrepeatable Read）

在同一事务中，两次读取同一数据，得到内容不同

事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致
* 幻读（Phantom Read）

同一事务中，用同样的操作读取两次，得到的记录数不相同

系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样

## MySql的四中隔离级别
* Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。

读取未提交的数据，则会发生赃读
* Read Committed（读取提交内容）

一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别，但非MySql一个事务多次读取的过程中，另一个事务可能对同一条数据做修改并提交，导致前一个事务多次读取到的数据不一致，则会发生不可重复读
* Repeatable Read（可重读）

它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这是MySql的默认隔离级别
但，此级别依然会发生幻读
* Serializable（可串行化）

它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题

|隔离级别|	读数据一致性|	赃读|	不可重复读|	幻读|
|--------|--------|--------|--------|--------|
|Read Uncommitted|	最低级别，只能保证不读取物理上损坏的数据|	√|	√|	√|
|Read Committed|	语句级|	×|	√|	√|
|Repeatable Read|	事务级|	×|	×|	√|
|Serializable|	最高级别，事务级|	×|	×	|×|
低级别的隔离一般支持更高的并发处理，并拥有更低的系统开销。高级别的隔离可靠性较高，但系统开销较大。

## 乐观锁与悲观锁
乐观锁(Optimistic Lock)，是指操作数据库时(更新操作)，总是认为这次的操作不会导致冲突，不到万不得已不去拿锁，在更新时采取判断是否冲突，适用于读操作远多于更新操作的情况。

乐观锁并没有被数据库实现，需要自行实现，通常的实现方式为在表中增加版本version字段，更新时判断库中version与取出时的version值是否相等，若相等则执行更新并将version加1，若不相等则说明数据被其他线程(进程)修改，放弃修改。
```
select (age, version) from user where id = #{id};
# 其他操作
update user set age = 18, version = version + 1 where id = #{id} and version = #{version} 
```
悲观锁(Pessimistic Lock），是指操作数据库时(更新操作)，总是认为这次的操作会导致冲突，每次都要通过获取锁才能进行数据操作，因此要先确保获取锁成功再进行业务操作。

悲观锁需要数据库自身提供支持，MySql提供了共享锁和排他锁来实现对数据行的锁定

## MySql InnoDB引擎 锁
nnoDB实现了以下两种类型的行锁：

- 共享锁 (S): 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
- 排他锁 (X): 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁

||X	|S|
|------|------|------|
|X|	冲突|	冲突|
|S|	冲突|	兼容|

> 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X）

> 对于普通SELECT语句，InnoDB不会加任何锁

事务可以通过以下语句显式地给记录集加共享锁或排他锁：

* 共享锁: `SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`，等同读锁
* 排他锁: `SELECT * FROM table_name WHERE ... FOR UPDATE`，等同写锁

用`SELECT ... IN SHARE MODE`获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用`SELECT... FOR UPDATE`方式获得排他锁。